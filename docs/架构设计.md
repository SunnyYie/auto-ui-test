# 架构设计

## 1. 总体架构

三层架构：**解析与规划层 (Brain)** → **适配层 (Adapter)** → **执行层 (Runtime)**

```text
┌─────────────┐     ┌──────────────────┐     ┌─────────────────┐     ┌──────────┐
│  用户输入     │ ──▶ │  LLM Planner     │ ──▶ │  Hybrid Adapter  │ ──▶ │ Browser  │
│  (自然语言)   │     │  (解析与规划层)    │     │  (适配层)         │     │ (执行层)  │
└─────────────┘     └──────────────────┘     └─────────────────┘     └──────────┘
                          │                        │
                    api/llm-client.js         api/adapter.js
                    api/schema.js             Playwright + Zerostep
```

**核心流程：**

1. **用户** 输入自然语言（如 "登录系统并验证主页"）
2. **LLM Planner** 解析意图，拆解为标准化的指令流 JSON
3. **Hybrid Adapter** 执行指令：Playwright 优先（毫秒级） + AI 兜底（秒级）
4. **Browser** 执行操作并返回结果

---

## 2. 模块设计

### 2.1 解析与规划层 — api/llm-client.js

**职责：** 接收自然语言，输出统一指令流 (Unified Instruction Stream)

- **输入：** 用户 Prompt
- **模型：** Anthropic 兼容接口，通过 Authorization Bearer 认证
- **输出：** 标准化 JSON 指令数组
- **核心函数：** parseIntent(prompt) — 调用 LLM，返回校验后的指令流

**System Prompt 关键规则：**

1. 严格输出纯 JSON 数组，不要 markdown 标记
2. 交互操作必须提供 semantic_locator，尽量同时提供 fallback_selector
3. 不要在 navigate 后添加多余的 wait 步骤
4. verify 断言中的关键词用引号包裹（用于关键词提取优化）
5. wait 仅用于等待动态内容，必须提供 selector
6. 最少步骤原则，不生成冗余步骤

### 2.2 统一指令 Schema — api/schema.js

**职责：** 定义 LLM 与适配器之间的契约格式

**Unified Schema 定义：**

```json
{
  "step_id": 1,
  "action_type": "navigate | click | input | verify | wait | select | hover | press | scroll",
  "params": {
    "url": "导航地址 (navigate)",
    "semantic_locator": "元素语义描述，英文 (click/input/hover/select)",
    "fallback_selector": "CSS 选择器兜底，可选 (click/input/hover/select)",
    "value": "输入内容或选择项 (input/select)",
    "assertion": "断言描述 (verify)",
    "selector": "等待的 CSS 选择器 (wait)",
    "key": "按键名 (press)",
    "direction": "滚动方向 up/down/top/bottom (scroll)"
  },
  "description": "步骤中文描述"
}
```

**校验函数：** validateInstruction() / validateInstructionStream()

### 2.3 混合适配器 — api/adapter.js

**职责：** 核心执行层，将 JSON 指令转换为浏览器操作

**混合策略 — Playwright 优先 + AI 兜底：**

```text
fallback_selector 存在?
  ├─ 是 → waitFor(attached) → 可见? → Playwright fill/click
  │                               └─ 不可见 → JS DOM 强制操作 (evaluate)
  │                                              └─ 失败 → Zerostep AI 兜底
  └─ 否 → Zerostep AI 直接执行
```

**各操作处理策略：**

| 操作     | 策略                                                                                        |
| -------- | ------------------------------------------------------------------------------------------- |
| navigate | Playwright page.goto()，使用 domcontentloaded 事件                                          |
| input    | waitFor(attached) → 可见则 fill() / 不可见则 JS DOM 设值 + dispatchEvent('input') → AI 兜底 |
| click    | waitFor(attached) → 可见则 click() / 不可见则 dispatchEvent('click') → AI 兜底              |
| verify   | 提取断言中的关键词 → page.content().includes() 原生检测 → AI 兜底                           |
| wait     | locator.first().waitFor() → 超时回退 domcontentloaded + 500ms                               |
| select   | Playwright selectOption() → AI 兜底                                                         |
| hover    | Playwright hover() → AI 兜底                                                                |
| press    | Playwright keyboard.press()                                                                 |
| scroll   | evaluate() 执行 window.scrollTo()                                                           |

**SPA 渲染等待（登录测试验证中的改进）：**

input/click 操作前增加 waitFor({ state: 'attached', timeout: 10000 }) 等待元素挂载到 DOM，解决 SPA 页面在 domcontentloaded 时组件尚未渲染的问题。

### 2.4 工作流引擎 — api/workflow.js

**职责：** 编排器，串联 LLM 解析 → 适配器执行 → 结果汇总

**核心函数：** runWorkflow(prompt, context, options)

| 选项        | 类型    | 默认值 | 说明               |
| ----------- | ------- | ------ | ------------------ |
| stopOnError | boolean | true   | 步骤失败时是否停止 |
| stepDelay   | number  | 0      | 步骤间延迟（毫秒） |
| useCache    | boolean | true   | 是否使用指令流缓存 |

**关键优化机制：**

1. **指令缓存** — 基于 prompt 的 MD5 哈希缓存到 .cache/ 目录，后续运行跳过 LLM 调用
2. **并行导航** — 首次运行时从 prompt 中提取 URL，Promise.all 同时执行 LLM 解析和 page.goto()
3. **缓存可手动微调** — 缓存的 JSON 文件支持手动编辑修正选择器，实现"半自动"优化

---

## 3. 验证场景与性能数据

### 3.1 百度搜索测试

**场景：** 打开百度搜索 Playwright 并验证结果

| 阶段               | 耗时         | 说明                      |
| ------------------ | ------------ | ------------------------- |
| 初始基准 (AI 执行) | 37.2s        | Zerostep AI 每次 4-8s     |
| 策略切换           | 20-30s       | Playwright 优先，减少等待 |
| 缓存模式           | **4.3-5.8s** | DOM 强制操作 + 指令缓存   |
| 首次运行           | **7.1s**     | LLM + 导航并行            |

### 3.2 登录功能测试

**场景：** 打开登录页 → 输入凭据 → 点击登录 → 验证主页（SPA 页面，Element UI 组件）

| 阶段              | 耗时         | 说明                        |
| ----------------- | ------------ | --------------------------- |
| 首次运行 (含 AI)  | 19.9s        | LLM 生成错误选择器，AI 兜底 |
| 缓存 + 修正选择器 | **1.7-4.3s** | 全 Playwright，零 AI 调用   |

---

## 4. 关键经验与设计原则

### 4.1 混合策略的核心价值

- **确定性操作**（navigate / wait / press / scroll）直接 Playwright，不调用 AI
- **元素交互**（input / click）先用 CSS 选择器，失败再 AI 兜底
- **验证操作** 优先关键词提取 + 原生文本检测（50ms vs AI 5s+）

### 4.2 LLM 选择器不可靠

LLM 猜测的 fallback_selector 经常出错（如 button[type='submit'] vs 实际 button[type='button']、.content-left vs #content_left），这是架构中 AI 兜底机制的核心价值所在。通过指令缓存 + 手动修正，可实现"半自动"优化。

### 4.3 SPA 页面兼容

domcontentloaded 不代表 SPA 组件已渲染。交互操作前必须 waitFor({ state: 'attached' }) 等待元素挂载，而非简单用 count() 检查存在性。

### 4.4 消除 AI 调用是最大性能收益

| 优化手段       | 节省时间 | 原理                                |
| -------------- | -------- | ----------------------------------- |
| DOM 强制操作   | ~12s     | 绕过可见性检查，消除 2 次 AI 调用   |
| 指令缓存       | ~5s      | 跳过 LLM 调用，相当于"预编译"       |
| 并行导航       | ~2s      | LLM 解析与 page.goto() 无依赖可并行 |
| 关键词提取验证 | ~5s      | 原生文本检测替代 AI 断言            |

### 4.5 设计原则总结

1. **Playwright 优先** — AI 是兜底手段，不是默认路径
2. **快速失败 + 快速回退** — 超时尽可能短，回退策略轻量
3. **缓存驱动** — 将 LLM 解析从运行时移到编写时
4. **凭据隔离** — URL / 用户名 / 密码存储在 .env.local，不在代码中暴露
